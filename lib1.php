
<?php


///////////////////////////////////////////////////////////////////////////////////////////
//////////////		БИБЛИОТЕКА ФУНЦИИ ДЛЯ PHP-ПРОГРАММ		///////////////////


// Адрес для возврата на предыдущую страницу
$addr_ret = "http://u0845056.isp.regruhosting.ru";


///////////////////////////////////////////////////////////////////////////////////////////
/////////////		Функция преобразования строки в число 		///////////////////
//
//
//	Входные переменные : 	$stroka - Строка которую надо преобразовать в число.


function StrToFloat( $stroka )
{

// Обрезать пробелы слева и справа.
$stroka = trim($stroka);

// Определить длину строки
$dlina_stroka = strlen($stroka);

// Определить позицию разделителя целой и дробной части
$poz_t = strpos($stroka,'.');

if ($poz_t == 0)
{
	$poz_t = strpos($stroka,',');
}


if ($poz_t == 0)
{
	$poz_t = $dlina_stroka;
}


// Сброс признака отрицательного числа
$minus = 0;

// Преобразовать в число целую часть ( Строку левее разделителя)
$value=0;
$step=1;
$i=$poz_t-1;

while ($i>=0)
{
	$symbol = substr($stroka,$i,1);
	$code 	= ord($symbol);

	if (($code >= 48) && ($code <= 57))
	{
		$value1 = $code - 48;
		$value += $value1*$step;
		$step *= 10;
	}

	elseif (($code == 45) && ($i==0))
	{
		// Встретился минус. Установить признак отрицательного числа.
		$minus = 1;
		break;
	}

	else
	{
		$value = 0;
		break;
	}

	$i--;
}


if ( $poz_t+1 < $dlina_stroka )
{
	// У числа имеется дробная часть.
	// Преобразовать в числовое значение дробную часть (Правее разделителя)

	$step = 0.1;
	$i = $poz_t+1;

	while ($i < $dlina_stroka)
	{
		$symbol = substr($stroka,$i,1);
		$code 	= ord($symbol);

		if (($code >= 48) && ($code <= 57))
		{
			$value1 = $code - 48;
			$value += $value1*$step;
			$step /= 10;
		}
		else
		{
			$value = 0;
			break;
		}

		$i++;
	}
}


if ($minus == 1)
{
	// Установлен признак отрицательного числа.
	// Сменить знак числа.
	$value *= -1;
}


// Возврат числового значения.
return $value;

}


///////////////////////////////////////////////////////////////////////////////////////////////////////////
///////	  Создание HTML- кода изображающего список выбора на основе запроса к таблице базы данных   ///////
//
//
//
//	Входные переменные :	$TableName 	- Наименование таблицы базы данных по которой строиться список.
//
//				$KeyFieldName	- Имя поля в котором размещен "Идентификатор" (ключевое поле).
//
//				$NameFieldName	- Имя поля в котором размещено "Наименование".
//
//				$KeyResult	- Наименование переменной в которую записывается идентификатор
//						  (ключевое значение) выбранного элемента списка выбора.
//						  При вызове функции этому параметру должно быть сопоставлено выражение вида "name".
//						  А в программе обработчике нажатия кнопки "submit" формы номер пункта берется из переменной $name.
//
//				$NachKeyVal	- Идентификатор (ключевое значение) выбранного по умолчанию элемента
//						  списка выбора.
//
//				$rez_soed_mysql	- Дескриптор соединения с MySQL
//
//
// Замечание : 	В програмном фрагменте из которого идет вызов этой функции должен находиться текст описания формы.
//		В разделе "action" должена быть назначена программа обработчик нажатия на кнопку "submit" на форме.
//		В нее передается номер выбранного пункта.
//
//


function FieldToList ( $TableName, $KeyFieldName, $NameFieldName, $KeyResult, $NachKeyVal, $rez_soed_mysql )

{

// Очистка выходной строки предназначенной для хранения HTML-кода списка выбора.
$output = "";

// Создать текст запроса выбирающего значения ключевого поля и поля наименованиея для всех строк указанной таблицы.
$query = "SELECT $KeyFieldName, $NameFieldName FROM $TableName ";

// Выполнение запроса.
$result = mysql_query( $query, $rez_soed_mysql);


// Добавить в выходную строку заголовок списка выбора с указанием имени переменной в которой список выбора возвратит
// выбранное значение.
$output.="<SELECT name = '$KeyResult' \n";
$output.= "<option value=\"0\" > </ option >  \n";



// Счетчику записей результата запроса присвоить начальное значение равное 1.
$RecNum = 1;

// Перебор в цикле всех записей результата запроса и добавление их в список выбора.

while ( $tek_stroka = mysql_fetch_assoc($result) )
{
	// Считать идентификатор (ключ) из текущей строки результата запроса.
	$id = $tek_stroka["$KeyFieldName"];

	// Считать наименование из текущей записи результата запроса.
	$name = $tek_stroka["$NameFieldName"];

	// Создать очередной элемент списка выбора.
	// Возвращаемым значением при выборе этого пункта будет значение переменной $id.

	$output.= "<option value=\"$id\" ";

	if ($id == $NachKeyVal)
	{
		// Идентификатор (ключ) из текущейи записи результата запроса совпадает
		// идентификатором (ключевым выражением) заданного по умолчанию элемента.
		// Установить текущий создаваемый элемент в списке выбора каквыбранный по умолчанию.

		$output .= "selected";
	}

	// В качестве наименования выдаваемого в списке выбора и видимого пользователю будет
	// значение переменной $name.
	$output .= "> $name </ option >  \n";

	// Нарастить счетчик записей.
	$RecNum++;
}


// Добавить в выходную строку с HTML-кодом завершение списка выбора.
$output .="</select> \n";


// Завершение функции и возврат строки с HTML-кодом изображающим список выбора.
return $output;


}


//////////////////////////////////////////////////////////////////////////////////////////
///////	  Создание HTML- кода изображающего список выбора на основе массива	   ///////
//
//
// Входные переменные :	$Name	- Название массива в котором записаны наименования элементов которые надо вывести в список.
//
//			$NachVal- Номер элемента выдаваемого по умолчанию
//
//			$RezVal	- Номер элемента выбранного в списке выбора.
//				  При вызове функции этому параметру должно быть сопоставлено выражение вида "name".
//				  А в программе обработчике нажатия кнопки "submit" формы номер пункта берется из переменной $name.
//
//
// Замечание : 	В програмном фрагменте из которого идет вызов этой функции должен находиться текст описания формы.
//		В разделе "action" должена быть назначена программа обработчик нажатия на кнопку "submit" на форме.
//		В нее передается номер выбранного пункта.
//
//

function BoundToList($Name, $NachVal, $ResVal )
{

// Очистка выходной строки предназначенной для хранения HTML-кода изображающего список выбора.
$output ="";

// Добавить в выходную строку заголовок списка выбора с указанием имени переменной в которой он
// возвратит номер выбранного элемента.
$output.="<select name='$ResVal' \n";

// Перебор в цикле всех элементов массива.
for ($i=0; $i<count($Name); $i++)
{
	// Создать очередной пункт списка выбора. В качестве возвращаемого значения при выборе этого пункта списка будет номер элемента.
	$output.= "<option value=\"$i\" ";

	if ($i == $NachVal)
	{
		// Текущий номер элемента массива, равен номеру элемента массива выдаваемого по умолчанию.
		// Установить текущий, создаваемый элемент списка выбранным по умолчанию.
		$output .= "selected";
	}

	// В качестве наименования выдаваемого в списке выбора и видимого пользователем будет значение этого элемента массива.
	$output .= "> $Name[$i] </option> \n";
}


// Добавить в выходную строку с HTML-кодом завершение списка выбора.
$output .="</select> \n";


// Завершение функции и возврат строки с HTML-кодом изображающим список выбора.
return $output;

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////		Построение HTML-кода изображающего таблицу содержащую результ выполнения запроса	////////
//
//
//	Входные переменные : 	$query 		- Текст запроса.
//
//				$rez_soed_mysql	- Дескриптор соединения с MySQL
//
//

function QueryToTable( $query, $rez_soed_mysql)

{

// Перевод строки
printf("\n");


// Выполненние запроса.
$result = mysql_query( $query, $rez_soed_mysql );

// Выдатьзаголовок таблицы.
$output = " <table border=1> \n";
printf("%s",$output);

// Выдать заголовки столбцов (полей).

// Добавить начало строки
$output = "<tr> \n";
printf("%s",$output);


// Выдать колонки с заголовками столбцов.
while ( $field = mysql_fetch_field($result) )
{
	$output = "<th>  $field->name  </th> \n";
	printf("%s",$output);
}

// Выдать конец строки
$output = "</tr> \n";
printf("%s",$output);

// Перебор всех строк из результата запроса и выдача их в виде строк таблицы.
while ($tek_stroka = mysql_fetch_assoc($result))
{
	// Выдать новую строку в таблицу
	$output = "<tr> \n";
	printf("%s",$output);

	// Перебор всех полей текущей строки результата запроса и выдача каждого поля в колонку строки.
	foreach($tek_stroka as $col=>$val)
	{
		// Выдать значение очередного поля в текущую таблицу.
		$output = " <td>$val</td> \n";
		printf("%s",$output);
	}

	// Закрыть очередную строку таблицы.
	$output = "</tr> \n";
	printf("%s",$output);
}

// Выдать закрытие таблицы.
$output = "</table> \n";
printf("%s",$output);


}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////// 		ФУНКЦИЯ СОЗДАЮЩАЯ ТЕКСТ ПРОГРАММЫ ДЛЯ ЗАГРУЗКИ УКАЗАННОЙ ТАБЛИЦЫ БАЗЫ ДАННЫХ 		////////////
//
//
//	Входные переменные : 	$name_table	- Наименование таблицы.
//
//				$rez_soed_mysql	- Дескриптор соединения с MySQL
//
//

function ZagrusTableText( $name_table, $rez_soed_mysql)
{

// Определить количество строк в очередной таблице базы данных.
$kol_str_tab=0;
$rez_zapros = mysql_query("SELECT count(*) FROM ".$name_table,$rez_soed_mysql);
while ($tek_stroka = mysql_fetch_row($rez_zapros))
{
	$kol_str_tab = $tek_stroka[0];
	break;
}

// Создать текст запроса извлекающего все строки таблицы.
$textQuery="SELECT * FROM ".$name_table." LIMIT 1";

// Выполненние запроса.
$result = mysql_query( $textQuery, $rez_soed_mysql );

// Записать в массивы наименования, типы полей таблицы, определить номер поля являющегося первичным ключом.
$nom_primary_key = -1;
$i=0;
while ( $field = mysql_fetch_field($result) )
{
	$name_pole[$i] = $field->name;
	$type_pole[$i] = $field->type;
	$klee_pole[$i] = $field->primary_key;
	$long_pole[$i] = $field->max_length;
	if ($field->primary_key) $nom_primary_key=$i;
	$i++;
}

// Выдать наименование и типы полей таблицы
for ($i=0; $i<count($name_pole); $i++)
{
	printf(" %s  %s  %d  %d  |  ", $name_pole[$i], $type_pole[$i], $klee_pole[$i], $long_pole[$i]);
}
printf("\n");



// Установить счетчик строк текущей таблицы в 1.
$nom_str=1;

// Установить в 1 счетчик команд
$n=1;

// Задать значение начального номера строки с которой должена начаться выборка. 
$nom_str1=0;


while ($nom_str1 < $kol_str_tab)
{
	if ($nom_primary_key >=0)
	{
		// У текущей таблицы обнаружен первичный ключ.
		// Создать запрос выбирающий записи таблицы отсортированными по возрастанию первичного ключа.
		$textQuery="SELECT * FROM ".$name_table." ORDER BY ".$name_pole[$nom_primary_key]." LIMIT ".sprintf("%d",$nom_str1).", 1000 ";
	}
	else
	{
		// У текущей таблицы нет первичного ключа
		// Создать запрос выбирающий записи таблицы в произвольном порядке.
		$textQuery="SELECT * FROM ".$name_table." LIMIT ".sprintf("%d",$nom_str1).", 1000 ";
	}

	// Выполнить запрос выбирающий записи таблицы.
	$result = mysql_query( $textQuery, $rez_soed_mysql );

	// Выдать заголовок таблицы.
	$output = " <table border=0> \n";
	printf("%s",$output);

	// Перебор всех строк из результата запроса.
	while ($tek_stroka = mysql_fetch_assoc($result))
	{
		// Создать строку текста PHP-программы загружающей данные в таблицу базы данных
		$str_php= "<tr><td>";
		$str_php .= " \$rez_zapros = mysql_query(\"INSERT INTO ".$name_table." VALUES (";

		// Обнулить счетчик полей.
		$i=0;

		// Перебор всех полей текущей строки результата запроса и добавление из к строке текста PHP-программы.

		foreach($tek_stroka as $col=>$val)
		{
			// Добавить разделитель между полями
			if ($i>0)  $str_php .= ", ";

			// Для поля строкового типа поставить кавычку.
			if ( ($type_pole[$i]=='string') || ($type_pole[$i]=='datetime')) $str_php .= "'";

			if ($nom_primary_key==$i)
			{
				// Текущее поле является полем первичного ключа, добавить к тексту PHP-программы строку "NULL"
				// вызывающее автоматическую генерацию значения для ключевого поля.
				$str_php .= "NULL";

				// Запомнить значение поля первичного ключа.
				$val_klee = "$val";
			}
			else
			{
				if (($val == NULL) && ($type_pole[$i]!='string') && ($type_pole[$i]!='datetime'))
				{
					// Значение очередного поля базы данных равно NULL, добавить строку "NULL" к тексту PHP-программы.
					$str_php .= "NULL";
				}
				else
				{
					// Добавить значение очередного поля к тексту PHP-программы.
					$str_php .= "$val";
				}
			}

			// Для поля строкового типа поставить кавычку.
			if ( ($type_pole[$i]=='string') || ($type_pole[$i]=='datetime')) $str_php .= "'";

			// Нарастить счетчик полей
			$i++;
		}

		// Создать завершение строки PHP-программы загружающей данные в таблицу базы данных.
		$str_php .= ") \",\$rez_soed_mysql); ";

		// Закрыть строку.
		$str_php .= "</td></tr>";

		// Пока значение ключевого поля следующей записи второй таблицы меньше чем значение ключевого поля в первой таблице - 1
		// добавлять во вторую таблицу строки и сейчас же удалять их так чтобы автонумератор ключевого поля второй таблицы при
		// создании следующей записи стал равен значению ключевого поля текущей записи первой таблицы.

		while ( $nom_str < $val_klee )
		{
			// Сформировать текст запроса добавляющего пустые записи и выполнить его.
			$str_php1 ="<tr><td>";
			$str_php1.=" \$rez_zapros = mysql_query(\"INSERT INTO ".$name_table." VALUES (";

			for ($i=0; $i<count($name_pole); $i++)
			{
				// Добавить разделитель между полями
				if ($i>0) $str_php1 .= ", ";

				if ($nom_primary_key==$i)
				{
					// Текущее поле является полем первичного ключа, добавить к тексту PHP-программы строку "NULL"
					// вызывающее автоматическую генерацию значения для ключевого поля.
					//
					$str_php1 .= "NULL";
				}
				else
				{
					// Для поля строкового типа поставить пустую строку в кавычках, для типа дата и время
					// поставить нулевую дату и время, для числового целого типа поставить 0.
					//
					$pustota = "NULL";
					if ($type_pole[$i]=='string'  	) $pustota = "' '";
					if ($type_pole[$i]=='datetime'	) $pustota = "'0000-00-00 00:00:00'";
					if ($type_pole[$i]=='int'	) $pustota = "0";
					if ($type_pole[$i]=='boolean'	) $pustota = "0";
					if ($type_pole[$i]=='real'	) $pustota = "0.0";
					$str_php1 .= $pustota;
				}
			}

			// Конец строки
			$str_php1.=") \",\$rez_soed_mysql); </td></tr>";

			// Выдать очередную строку с текстом программы генерирующего создание пустой записи.
			printf("%s",$str_php1);

			// Выдать очередную строку с текстом программы выдающим результат выполнения предыдущей строки.
			$output = "<tr><td> printf(\" Команда № $n     Результат выполнения = %d  \",\$rez_zapros); </td></tr> ";
			printf("%s",$output);
			$n++;

			// Создать текст запроса удаляющего последнюю созданную строку.
			$str_php2 ="<tr><td>  \$rez_zapros = mysql_query(\"DELETE FROM ".$name_table." WHERE ".$name_pole[$nom_primary_key]."=$nom_str \",\$rez_soed_mysql); </td></tr>";

			// Выдать очередную строку с текстом программы удаляющую последнюю созданную запись.
			printf("%s",$str_php2);

			// Выдать очередную строку с текстом программы выдающим результат выполнения предыдущей строки.
			$output = "<tr><td> printf(\" Команда № $n     Результат выполнения = %d  \",\$rez_zapros); </td></tr> ";
			printf("%s",$output);
			
			// Нарастить счетчик команд.
			$n++;

			// Нарастить счетчик строк текущей таблицы.
 			$nom_str++;
		}

		// Выдать очередную строку с текстом программы в таблицу
		printf("%s",$str_php);

		// Выдать очередную строку с текстом программы выдающим результат выполнения предыдущей строки.
		$output = "<tr><td> printf(\" Команда № $n     Результат выполнения = %d  \",\$rez_zapros);  </td></tr> ";
		printf("%s",$output);

		// Нарастить счетчик команд.
		$n++;

		// Нарастить счетчик строк текущей таблицы.
		$nom_str++;
	}

	// Нарастить значение начального номера строки с которой должена начаться выборка. 
	$nom_str1+=1000;
}

// Выдать закрытие таблицы.
$output = "</table> \n";
printf("%s",$output);

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////	ОПРЕДЕЛИТЬ КЛЮЧЕВОЕ ПОЛЕ ТАБЛИЦЫ	////////////////////////////////////////////////////
//
//	Входные переменные : 	$name_table	- Наименование таблицы.
//
//				$rez_soed_mysql	- Дескриптор соединения с MySQL
//


function PoiskKeyPole( $name_table, $rez_soed_mysql)
{

// Создать текст запроса извлекающего все строки таблицы.
$textQuery="SELECT * FROM ".$name_table;

// Выполненние запроса.
$result = mysql_query( $textQuery, $rez_soed_mysql );

// Перебор в цикле всех полей таблицы и запоминание поля являющегося первичным ключом.
$name_primary_key = "NULL";
while ( $field = mysql_fetch_field($result) )
{
	if ($field->primary_key) $name_primary_key = $field->name;
}

return $name_primary_key;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////		ФУНКЦИЯ УСТАНОВЛЕНИЯ СОЕДИНЕНИЯ С БАЗОЙ ДАННЫХ 				/////////////////////////
//
//
//
//

function Connect_chernyh5()
{

//$login1 = "u31786_0";
//$parol1 = "d225k32923021972";
//$login2 = "u31786_0";

$login1 = "u0845056_default";
$parol1 = "5_g7K0OT";
$login2 = "u0845056_default";


// Задать начальное значение возвращаемого значения.
$value = 0;

// Соединение с MySQL
$rez_soed_mysql = mysql_connect("localhost", $login1, $parol1);

if ($rez_soed_mysql > 0)
{
	// Соединение с базой данных
	$rez_soed_bd = mysql_select_db( $login2 , $rez_soed_mysql );

	if ($rez_soed_bd > 0)
	{
		$value = $rez_soed_mysql;
	}
}


// Конец функции возврат дескриптора соединения с MySQL
return $value;

}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////	ФУНКЦИЯ ПОСТРОЕНИЯ HTML-КОДА  ИЗОБРАЖАЮЩЕГО ТАБЛИЦУ C РЕЗУЛЬТАТАМИ ВЫПОЛНЕНИЯ ЗАПРОСА И 		/////////
////////////////	КНОПКАМИ "УДАЛЕНИЕ", "РЕДАКТИРОВАНИЕ" ДЛЯ КАЖДОЙ СТРОКИ ТАБЛИЦЫ И КНОПКОЙ "ДОБАВИТЬ ЗАПИСЬ".		/////////
//
//
//	Входные переменные : 	$tableName	- Наименование таблицы
//
//				$query		- Текст запроса
//
//				$rez_soed_mysql	- Дескриптор соединения с MySQL
//
//
//	Замечание :	Для нормальной работы функции необходимо присутствие в каталоге в котором расположена эта библиотека
//			так же файлов "deleteRecord.php", "editRecord.php","addRecord.php".
//
//	1) "deleteRecord.php" вызывается при щелчке по кнопке "Удаление записи" и содержит PHP-программу обработчика события нажатия на эту кнопку.
//	2) "editRecord.php"   вызывается при щелчке по кнопке "Редактирование записи" и содержит PHP-программу обработчика события нажатия на эту кнопку.
//	3) "addRecord.php"    вызывается при щелчке по кнопке "Добавить запись" и содержит PHP-программу обработчика события нажатия на эту кнопку.
//
//

function QueryToEdit( $tableName, $query, $rez_soed_mysql )
{


// Выполнить запрос
$result = mysql_query($query, $rez_soed_mysql);

// В выходной строке $output записывается HTML-код изображающий таблицу с кнопками.

// Добавить в выходную строку заголовок таблицы.
$output = "<table border=1> \n";

// Добавить в выходную строку первую строку таблицы, представляющую из себя заголовки колонок таблицы.
$output .= "<tr> \n";	// Начало строки

// Перебор в цикле всех полей результата запроса и выдача их наименований в выходную строку.
while ($field = mysql_fetch_field($result))
{
	$output .= "<th> $field->name </th>	\n";
}

// Добавить к строке пустые столбцы в которых располагаются кнопки для редактирования и удаления этой строки.
$output .= "<th> </th> 		<th> </th> \n";
$output .= "</tr>	\n\n";				// Конец строки


// Получить наименование поля № 0, предполагая что оно является ключевым.
$keyField = mysql_fetch_field( $result, 0);
$keyName = $keyField->name;


////////////////////////////////////
//printf(" Сообщение из функции QueryToEdit() :             keyName = %s    ", $keyName );
///////////////////////////////////


// Перебор в цикле всех строк результата запроса.
while ($tek_stroka = mysql_fetch_assoc($result))
{
	// Создать очередную строку в таблице.
	$output .= "<tr> \n";	// Начало строки

	// Перебор в цикле всех полей (колонок) очередной строки.
	foreach ($tek_stroka as $col=>$val)
	{
		// Добавить к выходной строке значение очередного поля, из строки результата запроса.
		$output .= "<td> $val </td> \n";
	}

	// Считать значение ключевого поля текущей строки результата запроса.
	$keyVal = $tek_stroka["$keyName"];


	// Добавить в выходную переменную HTML-код изображающий в текущей строке маленькую форму,
	// на которой изображена кнопка "Удаление записи". Обработчиком нажатия на кнопку будет
	// программа "deleteRecord.php". Ей отсылаются наименование таблицы в которой надо удалить
	// строку, наименование ключевого поля этой таблицы и значение ключевого поля той записи
	// которую надо удалить.

	$output .= "<td>

		    <form action = \"deleteRecord.php\">

		    <input type  = \"hidden\"
			   name  = \"tableName\"
			   value = \"$tableName\">

		    <input type  = \"hidden\"
   			   name  = \"keyName\"
			   value = \"$keyName\">

		   <input  type  = \"hidden\"
			   name  = \"keyVal\"
			   value = \"$keyVal\">

		   <input  type  = \"submit\"
			   value = \"Удалить\">

		   </form>

		   </td> ";


	// Добавить в выходную переменную HTML-код изображающий в текущей строке маленькую форму,
	// на которой изображена кнопка "Редактирование записи". Обработчиком нажатия
	// на кнопку будет программа "editRecord.php". Ей отсылается наименование таблицы
	// в которой надо редактированть строку, наименование ключевого поля этой таблицы и
	// значение ключевого поля той записи которую надо редактировать.

	$output .= "<td>

		    <form action = \"editRecord.php\">

		    <input type  = \"hidden\"
			   name  = \"tableName\"
			   value = \"$tableName\">

		    <input type  = \"hidden\"
   			   name  = \"keyName\"
			   value = \"$keyName\">

		    <input type  = \"hidden\"
			   name  = \"keyVal\"
			   value = \"$keyVal\">

		    <input type  = \"submit\"
			   value = \"Редактировать\">

		    </form>

		    </td>  ";

	$output .= "</tr> \n";	// Конец строки
}



// Добавить в выходную переменную HTML-код изображающий в последней строке таблицы маленькую форму,
// на которой изображена кнопка "Добавить запись". Обработчиком нажатия на кнопку будет программа
// "addRecord.php". Ей отсылается неаименование таблицы в которой надо создать строку.

$output .= "	<td colspan=\"5\">

		<center>

		<form action  = \"addRecord.php\">

		<input  type  = \"hidden\"
			name  = \"tableName\"
			value = \"$tableName\">

		<input  type  = \"submit\"
			value = \"Создать запись\">

		</form>

		</center>

		</td>	";


// Добавить в выходную строку окончание таблицы.
$output .= "</table> \n";


// Конец программы. Возврат выходной переменной содержащий HTML-код выдающий таблицу
// с кнопками "Редактирование", "Добваление", "Удаление".

return $output;

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////	ФУНКЦИЯ ПОСТРОЕНИЯ HTML-КОДА ИЗОБРАЖАЮЩЕГО ФОРМУ РЕДАКТИРОВАНИЯ ЗАПИСИ. 		//////////////////////////////
//
//
// Функция не позволяет пользователю редактировать первое поле (которое по соглашению является ключевым и содержит идентификатор записи).
// Форма генерирует выпадающий список для внешних ключей в котором перечислены наименования записей таблицы на которую ссылаются внешние
// ключи. Внешние ключи должны называться "IDtable" где "table" название таблицы.
//
//	Входные параметры : 	$query 		- Текст запроса выбирающего одну запись таблицы базы данных.
//
//				$rez_soed_mysql	- Дескриптор соединения с MySQL
//
//
//		Замечание :	Обработчиком нажатия на кнопку "submit" формы сгенерированной этой функцией является PHP-программа "updateRecord.php".
//				Файл "updateRecord.php" должен распологаться в том же каталоге что и данная библиотека. В "updateRecord.php" передаются
//				переменные с именами такими же как имена полей в таблице базы данных и значениями заданными пользователем при проигрывании
//				HTML-кода сгенерированного этой функцией.


function SmartRToEdit( $query, $rez_soed_mysql)
{

// Выполнить запрос.
$result = mysql_query( $query, $rez_soed_mysql );

// Одну (первую) строку результата запроса выгрузить в ассоциативный массив. (Если запрос выдал много строк, тогда возьмется первая).
$row = mysql_fetch_assoc( $result );

// Получить название таблицы.
$fieldObj = mysql_fetch_field( $result , 0 );
$tableName = $fieldObj->table;

// Сформировать HTML-код изображающий форму, назначить обработчиком нажатия на кнопку "submit" файл "updateRecord.php" .
$output = "";
$output .= " <  form action=\"updateRecord.php\"  method=\"post\"  >  ";

// В скрытом поле "tableName"  отослать наименование таблицы.
$output .="  <input type=\"hidden\"  name=\"tableName\"    value=\"$tableName\"  >   ";

// Изобразить на форме начало таблицы.
$output .="<table border=1>   ";


// Обнулить счетчик полей.
$fieldNum=0;

// Перебор в цикле всех полей результата запроса. На экране рисуется таблица, каждое поле редактирования записи располрожено в строке этой таблицы.
foreach ($row as $col=>$val)
{

	if ( $fieldNum==0 )
	{
		// Это поле является ключевым (содержит идентификатор записи). Его нельзя редактировать.
		// Добавить в выходную переменную HTML-код создающий невидимое поле с именем таким же
		// как у текущей колонки и значением равным ключевому значению (идентификатору) текущей записи.
		//
		// Через это невидимое поле в программу-обработчик "updateRecord.php" передается идентификатор (ключ)
		// редактируемой строки таблицы.
		//
		$output .= " <tr>
			       <th>  $col  </th>
			       <td>  $val  <input  type=\"hidden\"  name=\"$col\"  value=\"$val\" > </td>
			    </tr>";
	}
	elseif  ( ( ДлинаСтроки( $col ) > 2 )  &&  ( Подстрока( $col, 0, 2) == "ID" ) )
	{
		// Длина наименования этого поля больше 2 и начинается оно м подстроки 	"ID".
		// Данное поле является ссылкой на внешний клю.ч и содержит идентификатор записи другой таблицы.
		//
		// Считать наименование той таблицы на которую ссылается внешний ключ, и по которой надо построить список.
		//
		$tableName1 = Подстрока(  $col, 2, ДлинаСтроки( $col ) - 2 );

		// Добавить в HTML-код фрагмент изображающий список выбора, поместив в него все возможные значения
		// из таблицы $tableName1 на которую ссылается внешний ключ. Установить в качестве начального значения
		// в списке выбора установленное в данный момент значение.
		//
		$valList = fieldToList( $tableName1, "ID", "Name", "col", $val );
		$output .= " <tr>   <th> $col </th>    <td> $valList </td>   </tr> ";
	}
	else
	{
		// Это обыкновенное поле. Добавить к выходной текстовой строке HTML-код изображающий текстовое поле ввода.
		// В программе - обработчике "updateRecord.php" содержимое этого поляф будет читаться из переменной имя
		// которой совпадает с именем текущего поля. Начальное значение этого текстового поля равно значению текущего
		// поля строки результата запроса.
		//
		$output .= " <tr>   <th> $col </th>    <td> <input type=\"text\" name=\"$col\"  value=\"$val\" > </td> </tr> ";
	}

	// Нарастить на 1 счетчик полей строки результата запроса.
	$fieldNum++;
}


// Добавить к выходной текстовой строке HTML-код изображающий кнопку с надписью "Изменить".
// При щелчке на этой кнопке идет отсылка переменных программе-обработчику "updateRecord.php".
//
$output .= "  <tr>
	          <td colspan=2>
		<center>  <input type=\"submit\"  value=\"Изменить\"  </center>
	           </td>
	    </tr>	";

//  Добавить к выходной строке HTML-код изображающий окончание таблицы.
$output .= " </table> ";

//  Добавить к выходной строке HTML-код изображающий  окончание формы.
$output .= " </form> ";

// Конец программы.
// Возврат строки содержащийц HTML-код изображающий форму редактирования записи таблицы базы даных.
//
return $output;

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////  			ФУНКЦИЯ ВЫЧЛЕНЕНИЯ НОМЕРОВ ТЕЛЕФОНА ИЗ ТЕКСТА				//////////////
//
//
// 	Входной параметр  :         $text1 - Исходный текст из которого надо вычленить номера телефонов
//
// 	Выходной параметр :   $kol_telefon - Количество найденных телефонных номеров
//
//  Возвращаемое значение : 	 $telefon2 - Массив в который записываются найденные номера телефонов
//
//


function Telefon_Text( $text1, &$kol_telefon )
{


// Объявление массива телефонного номера
$telefon[0] = null;

// Обнулить длину массива телефонного номера.
$k=0;

// Обнулить счетчик найденных телефонов.
$kol_telefon=0;

// Очистка строки 
$telefon2="";

// Перебор в цикле всех символов поля "text".
for ($i=0; $i<strlen($text1); $i++)
{
	// Считать очередной символ
	$s= $text1[$i];

	if (  ((ord($s)>=48) && (ord($s)<=57)) || ($s=='-') || ($s=='+') )
	{
		// Очередной символ является числовым или знаками "+" или "-".
		// Записать его в массив телефонного номера.
		$telefon[$k]=$s;
		$k++;
	}
	else
	{
		if ($k > 0)
		{
			if ($k > 6)
			{
				// Подсчет числа цифровых символов в номере телефона .
				$kol_cifr=0;
				for ($j=0; $j<$k; $j++) if ((ord($telefon[$j])>=48) && (ord($telefon[$j])<=57))  $kol_cifr++;

				// Выбрать из номера телефона только циферные символы, отбросив "8" и "+7"
				// и записать их в массив "$telefon1[]".
				$nach_poz=0;

				if ($kol_cifr > 10)
				{
					// Сотовый телефон
					if (($telefon[0]=='8') && ($telefon[1]=='-')) $nach_poz=2;
					if (($telefon[0]=='+') && ($telefon[2]=='-')) $nach_poz=3;
				}

				$telefon1="";
				$poz=0;
				for ($j=$nach_poz; $j<$k; $j++)
					if ((ord($telefon[$j])>=48) && (ord($telefon[$j])<=57))
					{
						$telefon1=substr_replace($telefon1,$telefon[$j],$poz,1);
						$poz++;
					}

				// Записать найденный телефонный номер в массив найденных телефонных номеров
				$telefon2[$kol_telefon] = $telefon1;

				// Нарастить счетчик найденных телефонов.
				$kol_telefon++;
			}

			$k=0;
		}

	}
}

if ($k > 6)
{
	// Подсчет числа цифровых символов в номере телефона .
	$kol_cifr=0;
	for ($j=0; $j<$k; $j++) if ((ord($telefon[$j])>=48) && (ord($telefon[$j])<=57))  $kol_cifr++;

	// Выбрать из номера телефона только циферные символы, отбросив "8" и "+7"
	// и записать их в массив "$telefon1[]".
	$nach_poz=0;

	if ($kol_cifr > 10)
	{
		// Сотовый телефон
		if (($telefon[0]=='8') && ($telefon[1]=='-')) $nach_poz=2;
		if (($telefon[0]=='+') && ($telefon[2]=='-')) $nach_poz=3;
	}

	$telefon1="";
	$poz=0;
	for ($j=$nach_poz; $j<$k; $j++)
		if ((ord($telefon[$j])>=48) && (ord($telefon[$j])<=57))
		{
			$telefon1=substr_replace($telefon1,$telefon[$j],$poz,1);
			$poz++;
		}

	// Записать найденный телефонный номер в массив найденных телефонных номеров
	$telefon2[$kol_telefon]= $telefon1;

	// Нарастить счетчик найденных телефонов.
	$kol_telefon++;
}


return $telefon2;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////  			ФУНКЦИЯ ВЫЧЛЕНЕНИЯ ОТДЕЛЬНЫХ СЛОВ ИЗ ТЕКСТА				/////////////
//
//
// 	Входной параметр  :         $text1 - Исходный текст из которого надо вычленить номера телефонов
//
// 	Выходной параметр :   $kol_slowo   - Количество найденных слов
//
//  Возвращаемое значение : 	 $slowo2   - Массив в который записываются найденные слова.
//
//



function Slowo_Text( $text1, &$kol_slowo )
{

// Описание массива "slowo2[]""
$slowo2[0] = "";

// Очистка найденного слова.
$slowo="";
$k=0;

// Обнулить счетчик найденных слов.
$kol_slowo=0;


// Перебор в цикле всех символов текста.
for ($i=0; $i<strlen($text1); $i++)
{
	// Считать очередной символ
	$s= $text1[$i];

	
	if (($s == ' ') || ($s == '.') || ($s == ',') || ($s == ';') || ($s == ':') || ($s == '!') ||    
	    ($s == '?') || ($s == '-') || ($s == '+') || ($s == '/') || ($s == '^') || ($s == '%') || 
	    ($s == '&') || ($s == '*') || ($s == '(') || ($s == ')') || ($s == '{') || ($s == '}') || 
	    ($s == '[') || ($s == ']') || ($s == '$') || ($s == '"') || ($s == '@') || ($s == '~') || 	
	    ($s == '_') || ($s == '~') || ($s == '#') || ($s == '№') || ($s == '>') || ($s == '<') || 	
	    ($s == '_') || ($s == '=') || 
	    (ord($s) == 13) || (ord($s) == 10)	)
	{
		// Очередной символ является разделителем.
		if ($k > 0)
		{
			// Массив слова не пуст.

			// Записать очередное слово в список слов.
			$slowo2[$kol_slowo] = $slowo;
			$kol_slowo++;
			
			// Очистка найденного слова.
			$slowo = "";
			$k=0;
		}
	}
	else
	{
		// Очередной символ является обычным буквенным или цифровым символом.
		// Добавить этот символ к массиву слова.
		$slowo .= $s;
		$k++;	
	}		

}


// Закончен перебор всех символов текста.
if ($k > 0)
{
	// Массив слова не пуст.

	// Записать очередное слово в список слов.
	$slowo2[$kol_slowo] = $slowo;
	$kol_slowo++;

	// Очистка найденного слова.
	$slowo = "";
	$k=0;
}



return $slowo2;


}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////  			ФУНКЦИЯ ПРОВЕРКИ ЗАНЕСЕН ЛИ ТЕКУЩИЙ ХОСТ В ЧЕРНЫЙ СПИСОК		//////////////
//
//
//		Входные параметры :	$ip		- IP-адрес проверяемого хоста
//					$rez_soed_mysql	- Дескриптор соединения с MySQL
//
//	    Возвращаемое значение :  1 - Текущий хост занесен в черный список
//				     0 - Текущий хост не занесен в черный список



function HostBlackList($ip,$rez_soed_mysql)
{

$kol_black_list = 0;

$rez_zapros = mysql_query("SELECT COUNT(*) FROM blacklist WHERE name='$ip' ",$rez_soed_mysql);

while ($tek_stroka = mysql_fetch_row($rez_zapros))
{
	$kol_black_list = $tek_stroka[0];
	break;
}

return $kol_black_list;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////   ФУНКЦИЯ РАЗДЕЛЯЮЩАЯ ТЕКСТ НА ОТДЕЛЬНЫЕ СЛОВА И ЗАПИСЫВАЮЩАЯ ИХ В ТАБЛИЦУ "index_word" БАЗЫ ДАННЫХ   //////
//
//	Входные параметры :	$text - Текстовая строка предназначенная для разделения на отдельные слова и
//					помещения в базу данных.
//
//
//

function IndexText($text)
{

// Обнулить указатель позиции в тексте
$poz_text = 0;

// Очистить слово
$slowo = "";

// Определить длину текста
$dl_text = strlen($text);

while ($poz_text < $dl_text)
{
	// Считать символ из текущей позиции текста	
	$s = $text[$poz_text];

	if (($s == " ") || ($s == "(") || ($s == ")") || ($s == ".") || ($s == ","))
	{
		// Обнаружен конец слова

		if (strlen($slowo) > 0)
		{
			// Слово не пустое. Выдать слово.
			printf("\n %s", $slowo);
			
			// Очистить слово
			$slowo = "";
		}

		// Пропустить в тексте пробелы и другие посторонние символы.
		while (($poz_text < $dl_text) && (($s == " ") || ($s == "(") || ($s == ")") || ($s == ".") || ($s == ",")))
		{
			$poz_text++;
			$s = $text[$poz_text];
		}

		// Если текст закончился тогда выход из цикла	
		if ($poz_text >= $dl_text) break;
	}
	else
	{
		// Считанный символ является буквой или цифрой. Присоединить его к слову.
		$slowo .= $s;

		// Нарастить указатель позиции в тексте.
		$poz_text++;
	}

}


if (strlen($slowo) > 0)
{
	// Слово не пустое. Выдать слово.
	printf("\n %s", $slowo);
}


}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////  	ФУНКЦИЯ ПРЕОБРАЗУЮЩАЯ РУССКИЕ СТРОЧНЫЕ БУКВЫ В ЗАГЛАВНЫЕ	/////////////////////
//
//
//		Входные параметры : 	$slowo	- Преобразуемое слово
//
//	    Возвращаемое значение :	$slowo  - Преобразованное слово
//
//

function StrToUpper_UTF8($slowo)
{

// Определить длину слова в байтах.
$dl = strlen($slowo);

// Замена латинских строчных букв на заглавные
$i=0;

while ($i < $dl)
{
        // Считать символ в виде одного байта
	    $kod0 = ord($slowo[$i]);

        // Сброс признака замены байта
        $prz_zam1 = false;

        // Если очередной символ слова являетя строчной латинской буквой в кодировке UTF-8 тогда преобразовать его в заглавную латинскую букву в кодировке UTF-8 и 
        // установить признак замены символа
        if  ((97 <= $kod0) && ($kod0 <= 122)) {$kod0 -=32;  $prz_zam1 = true; }   // Замена 'a'-'z'  на  'A'- 'Z'

        if ($prz_zam1)
        {
            // Была выполнена замена строчной русской буквы в кодировке UTF-8 на заглавную русскую букву  в кодировке UTF-8 
            // Записать в слово новуую букву (значения трёх байт)
            $slowo[$i]   = chr($kod0);
        }

	    // Перейти к следующей букве слова
	    $i++;   
}


// Замена русских строчных букв на заглавные
$i=0;

while ($i < $dl-1)
{
        // Считать символ в виде  двух байт
	    $kod0 = ord($slowo[$i]);
	    $kod1 = ord($slowo[$i+1]);

        // Сброс признака замены двух байт
        $prz_zam2 = false;

        // Если очередной символ слова являетя строчной русской буквой в кодировке UTF-8 тогда преобразовать его в заглавную русскую букву в кодировке UTF-8 и 
        // установить признак замены символа
	    if      (($kod0 == 208) && (176 <= $kod1) && ($kod1 <= 191)) {$kod1 -= 32;              $prz_zam2 = true;}   // Замена 'а'-'п'  на  'А'- 'П'
	    elseif  (($kod0 == 209) && (128 <= $kod1) && ($kod1 <= 143)) {$kod0 = 208; $kod1 += 32; $prz_zam2 = true;}   // Замена 'р'-'я'  на  'Р'- 'Я'
	    elseif  (($kod0 == 209) && ($kod1 == 145))                   {$kod0 = 208; $kod1 = 129; $prz_zam2 = true;}   // Замена 'ё' на 'Ё

        if ($prz_zam2)
        {
            // Была выполнена замена строчной русской буквы в кодировке UTF-8 на заглавную русскую букву  в кодировке UTF-8 
            // Записать в слово новуую букву (значения трёх байт)
            $slowo[$i]   = chr($kod0);
	        $slowo[$i+1] = chr($kod1);

	        // Перейти к следующей букве слова
	        $i+=2;   
        }
        else
        {
            // Не была выполнена замена 
	        // Перейти к следующей букве слова
	        $i++;   
        }
}

return $slowo;

}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////		ФУНКЦИЯ ВСТАВКИ СЛОВА В ТАБЛИЦУ "temp_word"			/////////////////////////////////////
//
//
//		Входные параметры : $rez_soed_mysql - Код результата соединения с MySQL
//				        	$id_session     - Идентификатор сессии.
//					        $slowo          - Вставляемое слово
//				      	    $ur_blis        - Уровень близости вставляемого слова
//					  	    $P              - Признак использования данного слова для дальнейших изменений 		
//					        $kol            - Количество слов в таблице "temp_word"
//
//    	Возвращаемое значение :	    1 - если вставка слова в таблицу "temp_word" выполнена.
//				      	            0 - если вставка слова в таблицу "temp_word" не выполнена.


function Wstawka_slowa_temp_word( $rez_soed_mysql, $id_session, $slowo, $ur_blis, $P, &$kol )
{

// Проверить есть ли уже вставляемое слово в таблице "temp_word"
$kol_slow=0;
$rez_zapros = mysql_query("SELECT count(*) FROM temp_word WHERE code_session='$id_session' and text='$slowo' ", $rez_soed_mysql);

while ($tek_stroka = mysql_fetch_row($rez_zapros))
{
	$kol_slow=$tek_stroka[0];
	break;
}

// Сброс признака вставки слова в массив.
$ret_value=0;

if (($kol_slow == 0) && ($kol < 5000) && (strlen($slowo) > 2) )
{
	// Слово не найдено в таблице "temp_word" и общее количество вставленных слов меньше 5000.
	// Вставить его в таблицу.	
	$rez_zapros = mysql_query("INSERT INTO temp_word  VALUES (NULL,'$id_session','$slowo','$ur_blis','$P')",$rez_soed_mysql);

	// Установить признак вставки слова в массив.
	$ret_value=1;

	// Нарастить счетчик слов.  	
	$kol++;
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	//
    //   printf("\n  Вставил слово  %s  с уровнем близости %d  ", $slowo, $ur_blis);
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////////////
}

// Выход из программы с возвратом признака вставки слова в массив.
return $ret_value;

}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Определить длину строки в символах для кодировки UTF-8
//
//	    Входные параметры :  stroka - Строка длину которой надо определить
//
//  Возвращаемое значение : Длина строки в символах

function strlen_UTF8($stroka)
{
    
// Определить длину строки в байтах.
$dl = strlen($stroka);

// Обнулить счётчик символов
$kol_symb = 0;

// Перебор в цикле всех байт строки
$i=0;

while ($i < $dl)
{
    // Получить очередной байт в виде числа
    $val = ord($stroka[$i]);

    // Получить бит № 7
    $bit7 = $val & bindec('10000000');
    $bit7 = $bit7 >> 7;

    // Получить бит № 6
    $bit6 = $val & bindec('01000000');
    $bit6 = $bit6 >> 6;

    // Получить бит № 5
    $bit5 = $val & bindec('00100000');
    $bit5 = $bit5 >> 5;

    // Получить бит № 4
    $bit4 = $val & bindec('00010000');
    $bit4 = $bit4 >> 4;

    // Получить бит № 3
    $bit3 = $val & bindec('00001000');
    $bit3 = $bit3 >> 3;

    if ($bit7 == 0) 
    {
        // Символ занимает 1 байт
        $dl_symb = 1;           // Длина символа 1
    }
    elseif (($bit7 == 1) && ($bit6 == 1)  && ($bit5 == 0))    
    {
        // Символ занимает 2 байта
        $dl_symb = 2;           // Длина символа 2
    }
    elseif (($bit7 == 1) && ($bit6 == 1) && ($bit5 == 1) && ($bit4 == 0))    
    {
        // Символ занимает 3 байта
        $dl_symb = 3;           // Длина символа 3
    }
    elseif (($bit7 == 1) && ($bit6 == 1) && ($bit5 == 1) && ($bit4 == 1)  && ($bit3 == 0))    
    {
        // Символ занимает 4 байта
        $dl_symb = 4;           // Длина символа 3
    }
    else
    {
        // Неизвестна длина символа
        $kol_symb = -1;
        $dl_symb = 0;           // Длина символа 0
        break;                  //  Досрочный выход из цикла        
    }

    $kol_symb++;            // Нарастить счётчик символов в строке на 1
    $i += $dl_symb ;        // Переход к следующему символу строки
}
    
// Возврат количества символов в строке    
return $kol_symb;    
    
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//  Выдать подстроку из строки
//
//	     Входные параметры :                   stroka  - Исходная строка из которой надо выделить подстроку
//                               nach_poz_substr_symb  - Позиция символа в исходной строке с которой начинается подстрока которую надо выделить  (c 1 по количество букв в слове)
//                                  dlina_substr_symb   - Длина подстроки в символах которую надо выделить
//
//   Возвращаемое значение :     Выделенная подстрока

function substr_UTF8($stroka, $nach_poz_substr_symb, $dlina_substr_symb)
{

// Определить длину строки в символах
$dlina_str_symb = strlen_UTF8($stroka);

// Очистка искомой подстрок
$substr="";

if ($nach_poz_substr_symb <= $dlina_str_symb)
{
    // Начальная позиция меньше или равна длине строки.

    // Определить длину строки в байтах.
    $dlina_str_byte = strlen($stroka);

    // Обнулить счётчик пройденных символов
    $kol_prohod_symb = 0;

    // Перебор в цикле всех байт строки
    $i=0;

    // Пропуск символов до начальной позиции подстроки
    while (($i < $dlina_str_byte) && ($kol_prohod_symb < $nach_poz_substr_symb-1))
    {
        // Получить очередной байт в виде числа
        $val = ord($stroka[$i]);

        // Получить бит № 7
        $bit7 = $val & bindec('10000000');
        $bit7 = $bit7 >> 7;

        // Получить бит № 6
        $bit6 = $val & bindec('01000000');
        $bit6 = $bit6 >> 6;

        // Получить бит № 5
        $bit5 = $val & bindec('00100000');
        $bit5 = $bit5 >> 5;

        // Получить бит № 4
        $bit4 = $val & bindec('00010000');
        $bit4 = $bit4 >> 4;

        // Получить бит № 3
        $bit3 = $val & bindec('00001000');
        $bit3 = $bit3 >> 3;

        if ($bit7 == 0) 
        {
            // Символ занимает 1 байт
            $dl_symb = 1;           // Длина символа 1
        }
        elseif (($bit7 == 1) && ($bit6 == 1)  && ($bit5 == 0))    
        {
            // Символ занимает 2 байта
            $dl_symb = 2;           // Длина символа 2
        }
        elseif (($bit7 == 1) && ($bit6 == 1) && ($bit5 == 1) && ($bit4 == 0))    
        {
            // Символ занимает 3 байта
            $dl_symb = 3;           // Длина символа 3
        }
        elseif (($bit7 == 1) && ($bit6 == 1) && ($bit5 == 1) && ($bit4 == 1)  && ($bit3 == 0))    
        {
            // Символ занимает 4 байта
            $dl_symb = 4;           // Длина символа 3
        }
        else
        {
            // Неизвестна длина символа
            $kol_prohod_symb = -1;
            $dl_symb = 0;           // Длина символа 0
            break;                  // Досрочный выход из цикла        
        }
  
        $kol_prohod_symb++;         // Нарастить счётчик символов в строке на 1
        $i += $dl_symb ;            // Переход к следующему символу строки
    }

    if ($kol_prohod_symb >= 0)
    {
        // Рассмотренный фрагмент строки не содержал ошибок

        // Обнулить счётчик пройденных символов
        $kol_prohod_symb = 0;

        // Обнулить счётчик байт искомой подстроки
        $nom_byte_substr = 0;

        // Записывание в выходной массив подстроки от начальной позиции указанной длины 
        while (($i < $dlina_str_byte) && ($kol_prohod_symb < $dlina_substr_symb))
        {
            // Получить очередной байт в виде числа
            $val = ord($stroka[$i]);

            // Получить бит № 7
            $bit7 = $val & bindec('10000000');
            $bit7 = $bit7 >> 7;

            // Получить бит № 6
            $bit6 = $val & bindec('01000000');
            $bit6 = $bit6 >> 6;

            // Получить бит № 5
            $bit5 = $val & bindec('00100000');
            $bit5 = $bit5 >> 5;

            // Получить бит № 4
            $bit4 = $val & bindec('00010000');
            $bit4 = $bit4 >> 4;

            // Получить бит № 3
            $bit3 = $val & bindec('00001000');
            $bit3 = $bit3 >> 3;

            if ($bit7 == 0) 
            {
                // Символ занимает 1 байт
                $dl_symb = 1;           // Длина символа 1 байт
                $substr .= chr($val);   // Записать первый байт однобайтного символа в подстроку
            }
            elseif (($bit7 == 1) && ($bit6 == 1)  && ($bit5 == 0))    
            {
                // Символ занимает 2 байта
                $dl_symb = 2;                 // Длина символа 2 байта
                $substr .= chr($val);         // Записать первый байт двухбайтного символа в подстроку
                $substr .= $stroka[$i+1];     // Записать второй байт двухбайтного символа в подстроку    
            }
            elseif (($bit7 == 1) && ($bit6 == 1) && ($bit5 == 1) && ($bit4 == 0))    
            {
                // Символ занимает 3 байта
                $dl_symb = 3;                // Длина символа 3 байта
                $substr .= chr($val);        // Записать первый байт трёхбайтного символа в подстроку
                $substr .= $stroka[$i+1];    // Записать второй байт трёхбайтного символа в подстроку        
                $substr .= $stroka[$i+2];    // Записать третий байт трёхбайтного символа в подстроку        
            }
            elseif (($bit7 == 1) && ($bit6 == 1) && ($bit5 == 1) && ($bit4 == 1)  && ($bit3 == 0))    
            {
                // Символ занимает 4 байта
                $dl_symb = 4;                 // Длина символа 4 байта
                $substr .= chr($val);         // Записать первый байт четырёхбайтного символа в подстроку
                $substr .= $stroka[$i+1];     // Записать второй байт четырёхбайтного символа в подстроку        
                $substr .= $stroka[$i+2];     // Записать третий байт четырёхбайтного символа в подстроку        
                $substr .= $stroka[$i+3];     // Записать четвёртый байт четырёхбайтного символа в подстроку        
            }
            else
            {
                // Неизвестна длина символа
                $kol_prohod_symb = -1;
                $dl_symb = 0;           // Длина символа 0
                break;                  // Досрочный выход из цикла        
            }

            $kol_prohod_symb++;                 // Нарастить счётчик пройденных символов в строке на 1
            $i += $dl_symb;                     // Переход к следующему символу строки
            $nom_byte_substr += $dl_symb;       // Переход к следующему символу создаваемой подстроки
        }
    }
}

// Выход из функции с возвратом найденной подстроки    
return $substr;
    
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Вывод строки $stroka разделённой на подстроки содержащие не более чем $max_kol символов
//

function print_string_utf8( $stroka, $max_len )
{
    // Определить длину выводимой строки
    $len_stroka = strlen_UTF8($stroka);

    // Перебор в цикле всех символов выводимой строки, перевод строки делается после выдачи не менее чем $max_len символов          
    $nom=0;
    
    while ($nom < $len_stroka) 
    {
        $stroka1 = "";
        $nom1    = 0;
        
        while (($nom < $len_stroka) && ($nom1 < $max_len))
        {
            $symb = substr_UTF8($stroka, $nom+1, 1);
            if  ((ord($symb) != 10) && (ord($symb) != 13))
            {
                $stroka1 = $stroka1.$symb;
                $nom1++;
            }
            if  (ord($symb) == 13)
            {
                $stroka1 = $stroka1." ";
                $nom1++;
            }
            $nom++;    
        }

        while (($nom < $len_stroka) && (substr_UTF8($stroka,$nom+1,1) != " "))
        {
            $symb = substr_UTF8($stroka, $nom+1, 1);
            if  ((ord($symb) != 10) && (ord($symb) != 13))
            {
                $stroka1 = $stroka1.$symb;
                $nom1++;
            }
            if  (ord($symb) == 13)
            {
                $stroka1 = $stroka1." ";
                $nom1++;
            }
            $nom++;    
        }
    
        printf("<br>");
        printf("%s", trim($stroka1));
    }

    
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







?>